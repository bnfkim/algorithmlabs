# ****잊어버린 비밀번호****

## 📍문제

### **문제**

---

지니는 알고리즘 사이트의 비밀번호 마지막 숫자 부분을 까먹어서 비상이다.

맞힐 수 있는 확률은 10분의1이지만 다시 한번만 틀리게 된다면 비밀번호를 바꿔야 하기 때문에 쪽지에 메모했던 힌트를 꺼냈다. 마지막 숫자의 값은 ‘A의 제곱은 B의 제곱보다 N만큼 크다’를 만족하는 자연수 (A, B)쌍의 수다. 지니의 비밀번호 마지막 자리 숫자를 구해주자.

### **입력**

---

첫째 줄에 테스트케이스의 수 T가 주어진다..

각 테스트케이스의 첫 줄에 N이 주어진다.

( 1 ≤ T ≤ 10, 1 ≤ N ≤ 1,000 )

### **출력**

---

각 테스트케이스마다 '#'과 테스트케이스의 번호, 공백을 출력한 뒤 유니의 비밀번호 마지막 자리를 출력한다.

### **예제 입력**

```
5
77
57
29
69
24

```

### **예제 출력**

```
#1 2
#2 2
#3 1
#4 2
#5 2
```

## 📍코드

```java
import java.util.Scanner;
public class Main{
    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for(int t=1; t<=T; t++){
            int n = sc.nextInt();
            int cnt = 0;
            /**
             * i의 범위를 구하는 게 중요한 포인트 .. !
             * n<=1000 이하이므로 1000이상 넘어가는 포인트를 찾아야한다.
             *  n*n - (n-1)*(n-1) <- 이렇게 바로 직전을 뺏을때가 차가 가장 적다
             *  n^2 - n^2 + 2n - 1 <- 1000과 가장 가까운 숫자는
             *  2n - 1 <- n=501 이면 1001 이 된다
             *  n = 500 일때 n 입력값 1000이 넘지 않다는 것을 알 수 잇다.
             */
            for(int i=1; i<501; i++){
                if(i*i < n) continue;
                for(int j=1; j<i; j++){
                    if((i*i - j*j) == n) cnt++;
                    else if((i*i - j*j) < n) break;
                }
            }
            System.out.println("#" + t + " " + cnt);
        }
    }
}
```

## 📍기록

            /**
             * i의 범위를 구하는 게 중요한 포인트 .. !
             * n<=1000 이하이므로 1000이상 넘어가는 포인트를 찾아야한다.
             *  n*n - (n-1)*(n-1) <- 이렇게 바로 직전을 뺏을때가 차가 가장 적다
             *  n^2 - n^2 + 2n - 1 <- 1000과 가장 가까운 숫자는
             *  2n - 1 <- n=501 이면 1001 이 된다
             *  n = 500 일때 n 입력값 1000이 넘지 않다는 것을 알 수 잇다.
             */

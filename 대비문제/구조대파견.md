# 구조대 파견

## 📍문제

### **문제**

---

유니는 불이 난 동네에 파견된 구조대원이다.

현재 불이 난 동네의 길은 1차원 좌표계로 표현 가능한데, 일부 좌표에 구조가 필요한 시민들이 존재한다.

당장 모든 시민을 구조할 수 없는 상황이기 때문에 유니는 우선 모든 시민을 한 곳에 모아두기로 결정했다. 모으는 위치는 어디든 상관 없지만, 모든 시민을 만나서 데리고 이동해야 하므로 유니는 모든 시민의 위치를 한 번 이상 방문해야 한다.

유니가 현재 위치 S에서 출발해 모든 시민을 만나기 위해 필요한 최소 이동 거리를 구하는 프로그램을 작성하시오.

### **입력**

---

첫째 줄에 테스트 케이스의 수 T(1<=T<=10)가 주어진다.

각각의 테스트 케이스의 첫 줄에 사람의 수 N과 유니의 시작 위치 S가 공백으로 구분되어 주어진다.

그 다음 줄에 N명의 1차원 좌표가 공백으로 구분되어 주어진다.

N은 300 이하의 자연수, S와 각 사람의 좌표는 5000 이하의 자연수로 중복되는 수는 없다.

### **출력**

---

각 테스트케이스에 대해 "#"과 테스트케이스의 번호를 출력한 뒤, 유니가 모든 사람을 구조하기 위해 필요한 최소 이동 거리를 출력한다.

### **예제 입력**

```
10
8 44
23 40 42 34 24 33 13 21
6 38
43 45 26 48 9 28
6 18
10 50 26 16 19 30
10 41
44 14 29 18 3 11 12 19 2 32
6 31
44 21 35 47 24 6
5 29
6 42 46 50 34
9 23
12 50 4 7 2 24 34 49 36
9 5
19 16 50 15 23 43 3 7 40
6 4
8 11 31 23 21 40
8 3
31 39 21 19 18 40 45 7

```

### **예제 출력**

```
1 31
#2 49
#3 48
#4 45
#5 57
#6 65
#7 69
#8 49
#9 36
#10 42
```

## 📍코드

```java
import java.util.Arrays;
import java.util.Scanner;
public class Main{
    public static void main(String[] args){

        // Please Enter Your Code Here
        Scanner sc = new Scanner(System.in);
        int T = sc.nextInt();
        for(int t=1; t<=T; t++){
            int n = sc.nextInt(); //사람 수
            int s = sc.nextInt(); //시작 위치
            int[] arr = new int[n]; //사람 위치 배열

            for(int i=0; i<n; i++) arr[i] = sc.nextInt();
            Arrays.sort(arr);
            int sum = 0;
            //유니 위치가 범위 밖을 벗어나는 경우
            if(s < arr[0])sum = arr[arr.length-1] - s;
            else if (s > arr[arr.length-1]) sum = s - arr[0];
            //유니 위치가 범위 안에 있는 경우
            else {
                sum = arr[arr.length-1] - arr[0];
                sum += Math.min(s - arr[0], arr[arr.length - 1] - s);
            }
            System.out.println("#" + t + " " + sum);
        }
    }
}
```

## 📍기록

- 해결방법
    - 현재 위치와 더 가까운 끝쪽으로 감 (a)
    - 끝 위치에서 반대쪽 끝 위치로 감 (b)
    - => result = a+b
